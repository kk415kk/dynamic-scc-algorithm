------
DELETE: E' = { (A,B) in E }, G = (V,E)
------
G contains:
  - a mapping of SCC to nodes --> SCC
  - a mapping of node to SCC ---> inverse_SCC

def remove_edges(E'):
  check_scc = set()

  for (A,B) in E':
    delete (A,B) from E
    if SCC(A) == SCC(B):
      check_scc.add(SCC(A))
      delete (A,B) from A's intracomponent edges
    else:
      delete (A,B) from A's intercomponent edges

  # Go through all the SCCs that are affected
  for scc in check_edges:
    run tarjan's algorithm on the scc in question, only considering nodes/edges within the scc

--------
  ADD: E' = { (A,B) in E }, G = (V,E) 
--------

def add_edges(E'):

  check_scc = set()
  for (A,B) in E':
    if scc(A) == scc(B):
      just add the edge to the intra_edges collection
      add the edge to the graph
    else:
      add edge to check_scc



  nodes = G.get_nodes()

  # Build mapping of edges and reverse edges
  new_edges = {}
  rev_new_edges = {}
  graft_nodes = set()
  for (A,B) in E':
    if A not in new_edges:
      new_edges[A] = set()
      new_edges[A].add(B)
    else:
      new_edges[A].add(B)

    if B not in rev_new_edges:
      rev_new_edges[B] = set()
      rev_new_edges[B].add(A)
    else:
      rev_new_edges[B].add(A)

    if A in nodes:
      graft_nodes.add(A)
    if B in nodes:
      graft_nodes.add(B)

  # Ensure that the graft nodes only have outgoing edges;
  graft_case = True
  for node in graft_nodes:
    if len(rev_new_edges[node]) != 0:
      graft_case = False
      break

  # Graft Case
  if graft_case:
    G' = build graph of new edges
    perform modified Tarjan on nodes/edges reachable by graft nodes only
    merge results into G by adding in the SCC info for all nodes not in G
      - also update the graft node's intercomponent edges

  # Non-graft Case
  else:
    run Tarjan

