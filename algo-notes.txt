EDGES
=======================
------
EDGES: DELETE: E' = { (A,B) in E }, G = (V,E)
------
Essentially, for each edge (A,B) to be deleted:
  - Check if the nodes A, B are in the same SCC
    - If they are NOT in the same SCC, just delete the edge 
      and remove them from the inter-SCC edges
    - If they ARE from the same SCC, keep track of the SCC
  - For each of the affected SCCs:
    - Run a limited version of Tarjan's algorithm:
      - Only consider the nodes/edges within the SCC
      - This generates a new set of SCCs
    - Use the generated components mapping and inverse index 
      on the components mapping to update the graph's internal
      data structures
    - Maintain the intra-SCC and inter-SCC edges:

G contains:
  - a mapping of SCC to nodes --> SCC
  - a mapping of node to SCC ---> inverse_SCC

PSEUDOCODE:
def remove_edges(E'):
  check_scc = set()

  for (A,B) in E':
    delete (A,B) from E
    if SCC(A) == SCC(B):
      check_scc.add(SCC(A))
      delete (A,B) from A's intracomponent edges
    else:
      delete (A,B) from A's intercomponent edges

  # Go through all the SCCs that are affected
  for scc in check_edges:
    run tarjan's algorithm on the scc in question, only considering nodes/edges within the scc

--------
EDGES: ADD: E' = { (A,B) not in E }, G = (V,E) 
--------
Idea: consider looking at the collapsed graph only. The current
      implementation easily allows for this, since we can look
      up the inter-SCC edges of all the nodes in an SCC relatively
      quickly (O(|size of the SCC|))
      
- For each (A,B) to be added:
  - Check if the nodes A, B are in the same SCC
    - If they ARE in the same SCC, just add the edge and insert
      into the inter-SCC data structure
    - If they are NOT in the same SCC, keep track of the edges
  - For all edges that need to be checked still:
    - Insert them into the graph and into the inter-SCC edge structure
    - Perform a limited Tarjan on the collapsed DAG of the graph by:
      - Taking the starting node of each edge that needs to be checked
        and lookup the SCC number of the node.
      - Grab all the inter-SCC edges from the nodes in this SCC and traverse
        those edges to the new SCCs
      - The components map and its inverse index that is outputted by this
        version of Tarjan's will have groups of SCC numbers rather than the
        original nodes
      - Any group that is larger than size 1 needs to have all of the SCCs
        inside it merged.
      - Move the relevant inter-SCC edges to the intra-SCC edge structure


NODES
===========
-------
NODES: DELETE: V' = { v in E or reverse_E }, G = (V,E)
-------
NOTE that it's better (and safer) to remove the edges before removing the nodes
- For each node v in V'
  - Check if there are any inbound/outbound edges on v using the 
    edge adjancency list and the reverse edges adjacency list
      - If there are any, remove them in bulk first
  - Look up v in the inverse index on components map
  - Remove v from inverse index
  - Remove v from its SCC in components map
  - Clean up components map if the SCC is empty now

-------
NODES: ADD: V' = { v not in E or reverse_E }, G = (V,E)
-------
- For each node v in V':
  - Add the node to the inverse index on the components map
  - Increment index counter
  - Add the node to the components map



POSSIBLE OPTIMIZATIONS:
- Keeping track of numbers we can re-use and using them before using the next index number for SCCs
- Heuristic of size of change / size of graph to see if we can do full-recompute instead
  - Need a hashing scheme so we don't change unchanged SCCs